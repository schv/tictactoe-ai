type: edu
custom_name: The undefeatable...
files:
- name: tests.py
  visible: false
  text: |
    from hstest.stage_test import *
    from hstest.test_case import TestCase
    from enum import Enum
    from typing import List, Optional
    from copy import deepcopy

    CheckResult.correct = lambda: CheckResult(True, '')
    CheckResult.wrong = lambda feedback: CheckResult(False, feedback)


    class FieldState(Enum):
        X = 'X'
        O = 'O'
        FREE = ' '


    def get_state(symbol):
        if symbol == 'X':
            return FieldState.X
        elif symbol == 'O':
            return FieldState.O
        elif symbol == ' ' or symbol == '_':
            return FieldState.FREE
        else:
            return None


    class TicTacToeField:

        def __init__(self, *, field: str = '', constructed=None):

            if constructed is not None:
                self.field = deepcopy(constructed)

            else:
                self.field: List[List[Optional[FieldState]]] = [
                    [None for _ in range(3)] for _ in range(3)
                ]

                field = field.replace("\"", "")

                for row in range(3):
                    for col in range(3):
                        index = (2 - row) * 3 + col
                        self.field[row][col] = get_state(field[index])

        def equal_to(self, other) -> bool:
            for i in range(3):
                for j in range(3):
                    if self.field[i][j] != other.field[i][j]:
                        return False
            return True

        def has_next_as(self, other) -> bool:
            improved: bool = False
            for i in range(3):
                for j in range(3):
                    if self.field[i][j] != other.field[i][j]:
                        if self.field[i][j] == FieldState.FREE and not improved:
                            improved = True
                        else:
                            return False
            return improved

        def differ_by_one(self, other) -> bool:
            have_single_difference = False
            for i in range(3):
                for j in range(3):
                    if self.field[i][j] != other.field[i][j]:
                        if have_single_difference:
                            return False
                        have_single_difference = True
            return have_single_difference

        def is_close_to(self, other) -> bool:
            return (
                self.equal_to(other)
                or self.has_next_as(other)
                or other.has_next_as(self)
            )

        @staticmethod
        def parse(field_str: str):

            lines = field_str.splitlines()
            lines = [i.strip() for i in lines]
            lines = [i for i in lines if
                     i.startswith('|') and i.endswith('|')]

            for line in lines:
                if len(line) != 9:
                    raise WrongAnswerException(
                        f"Line of Tic-Tac-Toe field should be 9 characters long\n"
                        f"found {len(line)} characters in \"{line}\"")
                for c in line:
                    if c not in 'XO|_ ':
                        return None

            field: List[List[Optional[FieldState]]] = [
                [None for _ in range(3)] for _ in range(3)
            ]

            y: int = 2

            for line in lines:
                cols = line[2], line[4], line[6]
                x: int = 0
                for c in cols:
                    state = get_state(c)
                    if state is None:
                        return None
                    field[y][x] = state
                    x += 1
                y -= 1

            return TicTacToeField(constructed=field)

        @staticmethod
        def parse_all(output: str):
            fields = []

            lines = output.splitlines()
            lines = [i.strip() for i in lines]
            lines = [i for i in lines if len(i) > 0]

            candidate_field = ''
            inside_field = False
            for line in lines:
                if '----' in line and not inside_field:
                    inside_field = True
                    candidate_field = ''
                elif '----' in line and inside_field:
                    field = TicTacToeField.parse(candidate_field)
                    if field is not None:
                        fields += [field]
                    inside_field = False

                if inside_field and line.startswith('|'):
                    candidate_field += line + '\n'

            return fields


    inputs = [
        "1 1", "1 2", "1 3",
        "2 1", "2 2", "2 3",
        "3 1", "3 2", "3 3"
    ]


    def iterate_cells(initial: str) -> str:
        index: int = -1
        for i in range(len(inputs)):
            if initial == inputs[i]:
                index = i
                break

        if index == -1:
            return ''

        full_input: str = ''
        for i in range(index, index + 9):
            full_input += inputs[i % len(inputs)] + '\n'

        return full_input


    class TicTacToeTest(StageTest):
        def generate(self) -> List[TestCase]:
            tests: List[TestCase] = []

            i: int = 0
            for input in inputs:
                full_move_input = iterate_cells(input)

                str_nums = input.split()
                x = int(str_nums[0])
                y = int(str_nums[1])

                if i % 2 == 1:
                    full_move_input = f'4 {i}\n' + full_move_input

                full_game_input = ''
                for _ in range(9):
                    full_game_input += full_move_input

                if i % 6 == 0:
                    initial = "start user easy\n"
                elif i % 6 == 1:
                    initial = "start easy user\n"
                elif i % 6 == 2:
                    initial = "start user medium\n"
                elif i % 6 == 3:
                    initial = "start medium user\n"
                elif i % 6 == 4:
                    initial = "start user hard\n"
                else:
                    initial = "start hard user\n"

                full_game_input = initial + full_game_input + "exit"

                tests += [TestCase(stdin=full_game_input)]

                i += 1

            tests += [
                TestCase(stdin="start easy easy\nexit"),
                TestCase(stdin="start medium medium\nexit"),
                TestCase(stdin="start hard hard\nexit"),

                TestCase(stdin="start medium easy\nexit"),
                TestCase(stdin="start easy medium\nexit"),

                TestCase(stdin="start medium hard\nexit"),
                TestCase(stdin="start hard medium\nexit"),

                TestCase(stdin="start easy hard\nexit"),
                TestCase(stdin="start hard easy\nexit"),

                TestCase(stdin=
                         "start user user\n" +
                         "1 1\n" +
                         "2 2\n" +
                         "1 2\n" +
                         "2 1\n" +
                         "1 3\n" +
                         "exit"),
            ]

            return tests

        def check(self, reply: str, attach: str) -> CheckResult:

            fields = TicTacToeField.parse_all(reply)

            if len(fields) == 0:
                return CheckResult.wrong(
                    "No fields found"
                )

            for i in range(1, len(fields)):
                curr: TicTacToeField = fields[i - 1]
                next: TicTacToeField = fields[i]

                stayed = curr.equal_to(next)
                improved = curr.has_next_as(next)

                if not (stayed or improved):
                    return CheckResult.wrong(
                        "For two fields following each " +
                        "other one is not a continuation " +
                        "of the other (they differ more than in two places)."
                    )

            return CheckResult.correct()


    if __name__ == '__main__':
        TicTacToeTest('tictactoe.tictactoe').run_tests()
  learner_created: false
- name: tictactoe/tictactoe.py
  visible: true
  text: |
    from copy import deepcopy
    from random import randint
    from typing import Tuple, List
    from enum import Enum
    from itertools import cycle


    def trace(f):
        def inner(*args, **kwargs):
            call = ", ".join(
                [str(a) for a in args] + [f"{k}={v}" for k, v in kwargs]
            )
            # print(f"{f.__name__}({call}) = ...")
            print(f"{f.__name__} = ...")
            ret = f(*args, **kwargs)
            # print(f"{f.__name__}({call}) = {ret}")
            print(f"{f.__name__} = {ret}")
            return ret
        return inner


    class Difficulty(Enum):
        EASY = "easy"
        MEDIUM = "medium"
        HARD = "hard"


    class GameStatus(Enum):
        NOT_STARTED = "Not started"
        NOT_FINISHED = "Game not finished"
        X_WINS = "X wins"
        O_WINS = "O wins"
        DRAW = "Draw"


    class Turn(Enum):
        X = "X"
        O = "O"

        def flipped(self):
            return Turn.X if self is Turn.O else Turn.O


    class Player:
        def validate_input(self, game, column: int, row: int) -> bool:
            return game.cell_available(column, row)

        def make_move(self, game) -> Tuple[int, int]:
            while True:
                column, row = self.get_input(game)
                if self.validate_input(game, column, row):
                    game.make_move(column, row)
                    return column, row

        def get_input(self, game) -> Tuple[int, int]:
            pass

        @staticmethod
        def spawn(turn: Turn, kind: str):
            if kind == "user":
                return Human(turn)
            elif kind in ["easy", "medium", "hard"]:
                return AI(turn, Difficulty(kind))
            else:
                raise ValueError


    class AI(Player):
        def __init__(self, turn: Turn, difficulty: Difficulty = Difficulty.EASY):
            self.turn = turn
            self.difficulty = difficulty
            self.move_calculator = {
                Difficulty.EASY: self.easy_move,
                Difficulty.MEDIUM: self.medium_move,
                Difficulty.HARD: self.hard_move,
            }[self.difficulty]

        def next_turn_victory(self, field, field_copy, turn, wanted_status):
            for i, row in enumerate(field):
                for j, cell in enumerate(row):
                    if cell == Field.empty_cell:
                        field_copy[i][j] = turn.value
                        if Field.check_given_field(field_copy) is wanted_status:
                            return Game.idx_to_coord(i, j)
                        else:
                            field_copy[i][j] = Field.empty_cell

        # @trace
        def easy_move(self, game):
            column = randint(1, 3)
            row = randint(1, 3)
            return column, row

        # @trace
        def medium_move(self, game):
            field = game.field.state
            field_copy = deepcopy(field)

            # TODO: try short circuit after fixing
            # if (result := self.next_turn_victory(field, field_copy, self.turn, GameStatus(f"{self.turn.value} wins"))) is not None:
            #     return result
            # elif (result := self.next_turn_victory(field, field_copy, self.turn.flipped(), GameStatus.DRAW)) is not None:
            #     return result
            # else:
            #     return self.easy_move(game)

            return self.next_turn_victory(field, field_copy, self.turn, GameStatus(f"{self.turn.value} wins")) \
                or self.next_turn_victory(field, field_copy, self.turn.flipped(), GameStatus(f"{self.turn.flipped().value} wins")) \
                or self.easy_move(game)

        def hard_move(self, game):
            raise NotImplementedError

        def get_input(self, game) -> Tuple[int, int]:
            column, row = self.move_calculator(game)
            return column, row

        def make_move(self, game) -> Tuple[int, int]:
            print(f'Making move level "{self.difficulty.value}"')
            return super(AI, self).make_move(game)


    class Human(Player):
        def __init__(self, turn: Turn):
            self.turn = turn

        def validate_input(self, game, column: int, row: int) -> bool:
            if not (column in range(1, 4) and row in range(1, 4)):
                print("Coordinates should be from 1 to 3!")
                return False
            elif not game.cell_available(column, row):
                print("This cell is occupied! Choose another one!")
                return False
            else:
                return True

        def get_input(self, game) -> Tuple[int, int]:
            while True:
                user_input = input("Enter the coordinates: ").strip()
                try:
                    column, row = [int(x) for x in user_input.split()]
                    return column, row
                except (TypeError, ValueError):
                    print("You should enter numbers!")


    class Field:
        empty_cell = "_"

        def __init__(self):
            self.state = [[self.empty_cell for _ in range(3)] for _ in range(3)]

        def decode_field(self, seq: str):
            iter_seq = iter(seq)
            self.state = [[next(iter_seq) for _ in range(3)] for _ in range(3)]

        def check_field(self):
            return self.check_given_field(self.state)

        @staticmethod
        def check_given_field(field: List[List[str]]) -> GameStatus:
            for i, _ in enumerate(field):
                if (cell := field[i][i]) != Field.empty_cell:
                    m1 = (i + 1) % 3
                    m2 = (i + 2) % 3

                    h = field[i][i] == field[i][m1] == field[i][m2]
                    v = field[i][i] == field[m1][i] == field[m2][i]
                    d1 = i == 1 and field[i][i] == field[m1][m1] == field[m2][m2]
                    d2 = i == 1 and field[i][i] == field[m1][m2] == field[m2][m1]

                    if any((h, v, d1, d2)):
                        return GameStatus(f"{cell} wins")

        def __str__(self):
            return f"""
    ---------
    | {" ".join(self.state[0])} |
    | {" ".join(self.state[1])} |
    | {" ".join(self.state[2])} |
    ---------"""


    class Game:
        status = GameStatus.NOT_STARTED
        empty_cell = "_"
        turns_left = 9

        def __init__(self, current_player: Player, pending_player: Player):
            self.current_player = current_player
            self.pending_player = pending_player
            self.players = (current_player, pending_player)
            self.field = Field()
            self.status = GameStatus.NOT_FINISHED
            self.turns = cycle(Turn)
            # turn = "X"
            self.current_turn = next(self.turns)

        def load_from_save(self, seq: str):
            xs = seq.count('X')
            os = seq.count('O')

            self.turns_left -= xs + os
            self.current_turn = Turn('X' if xs == os else 'O')
            del self.turns
            self.field.decode_field(seq)

        def next_turn(self):
            # self.turn = 'O' if self.turn == 'X' else 'X'
            self.current_turn = next(self.turns)
            self.current_player, self.pending_player = self.pending_player, self.current_player

        def cell_available(self, column: int, row: int) -> bool:
            i, j = self.coord_to_idx(column, row)
            return self.field.state[i][j] == Field.empty_cell

        def make_move(self, column: int, row: int):
            i, j = self.coord_to_idx(column, row)
            self.field.state[i][j] = self.current_turn.value
            self.next_turn()
            self.turns_left -= 1
            print(self.turns_left)

        @staticmethod
        def coord_to_idx(column: int, row: int) -> Tuple[int, int]:
            return 3 - row, column - 1

        @staticmethod
        def idx_to_coord(i: int, j: int) -> Tuple[int, int]:
            return j + 1, 3 - i

        def check_field(self):
            field = self.field.state

            if (result := self.field.check_field()) is not None:
                self.status = result
            elif not self.turns_left:
                self.status = GameStatus.DRAW



    def main():
        while True:
            user_input = input("Input command: ").strip()
            if user_input == "exit":
                return
            try:
                start, x_player_kind, o_player_kind = user_input.split()
                if start != "start":
                    raise ValueError
                if x_player_kind not in ["user", "easy", "medium"] or o_player_kind not in ["user", "easy", "medium"]:
                    raise ValueError
                break

            except ValueError:
                print(("Bad parameters"))

        x_player = Player.spawn(Turn("X"), x_player_kind)
        o_player = Player.spawn(Turn("O"), o_player_kind)

        human = Human(Turn("X"))
        ai = AI(Turn("O"), Difficulty("easy"))

        game = Game(x_player, o_player)
        print(game.field)

        while game.status is GameStatus.NOT_FINISHED:
            game.current_player.make_move(game)
            game.check_field()
            print(game.field)

        print(game.status.value)


    if __name__ == '__main__':
        main()
  learner_created: true
feedback_link: https://hyperskill.org/projects/82/stages/456/implement
status: Solved
feedback:
  message: Congratulations! Continue on <a href="https://hyperskill.org/projects/82/stages/456/implement">JetBrains
    Academy</a>
  time: Tue, 30 Jun 2020 10:04:47 UTC
record: 5
